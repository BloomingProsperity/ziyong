---
skill_id: "19-fault-decision-tree"
name: "故障决策树"
version: "1.1.0"
status: "stable"                    # draft | beta | stable | deprecated
implementation_status: "partial"    # none | partial | complete
difficulty: 4
category: "evolution"

description: "故障分类、决策路径、自动恢复的标准化处理流程"

triggers:
  - condition: "error.occurred == true"
  - condition: "response.status_code >= 400"
  - condition: "extraction.failed == true"

dependencies:
  required:
    - skill: "08-diagnosis"
      reason: "日志分析支持"
  optional:
    - skill: "17-feedback-loop"
      reason: "经验记录"

external_dependencies:
  required: []
  optional: []
---

# 19-fault-decision-tree.md - 故障决策树

## 模块目标

| 目标 | SLO | 适用范围 | 降级策略 |
|------|-----|----------|----------|
| 故障自愈 | 自愈率 ≥ 80% | 可恢复故障 | 升级至人工 |
| 快速决策 | 决策时间 < 3s | 已知故障类型 | 使用默认策略 |
| 完整记录 | 记录率 ≥ 99% | 所有故障 | 异步补录 |

**执行原则**: 故障 → 分类 → 查决策树 → 执行恢复 → 记录结果

---

## 一、故障分类总览

```
故障类型
├── 网络层故障
│   ├── 连接超时
│   ├── DNS解析失败
│   ├── SSL证书错误
│   └── 代理失效
├── HTTP层故障
│   ├── 4xx 客户端错误
│   └── 5xx 服务端错误
├── 反爬层故障
│   ├── 验证码拦截
│   ├── IP封禁
│   ├── 账号限制
│   └── 行为检测
├── 数据层故障
│   ├── 元素定位失败
│   ├── 数据格式变化
│   ├── 内容为空
│   └── 编码异常
├── 浏览器层故障
│   ├── 页面崩溃
│   ├── 内存溢出
│   ├── 脚本执行错误
│   └── 资源加载失败
└── 逻辑层故障
    ├── 无限循环
    ├── 状态丢失
    └── 预期不符
```

---

## 二、网络层故障决策树

### 2.1 连接超时 (Connection Timeout)

```
连接超时
│
├─→ 检查: 目标服务器是否可达?
│   │
│   ├─ 否 → 服务器可能宕机
│   │   ├─→ 尝试访问目标网站首页
│   │   │   ├─ 成功 → 仅目标URL有问题，尝试其他入口
│   │   │   └─ 失败 → 网站整体不可用
│   │   │       ├─→ 记录: "目标网站不可用，时间:{timestamp}"
│   │   │       ├─→ 等待 5 分钟后重试
│   │   │       ├─→ 最多重试 3 次
│   │   │       └─→ 仍失败 → 向用户报告，请求替代方案
│   │   │
│   └─ 是 → 网络配置问题
│       ├─→ 检查当前代理是否有效
│       │   ├─ 代理无效 → 切换到下一个代理
│       │   └─ 代理有效 → 增加超时时间 (30s → 60s → 120s)
│       │
│       └─→ 仍失败 → 尝试直连 (如果允许)
│
└─→ 决策记录:
    {
      "fault_type": "connection_timeout",
      "url": "{url}",
      "proxy_used": "{proxy}",
      "attempts": [],
      "resolution": "{最终采取的措施}",
      "outcome": "success|failure"
    }
```

### 2.2 DNS解析失败

```
DNS解析失败
│
├─→ 验证: 域名是否拼写正确?
│   ├─ 错误 → 修正域名，重新请求
│   └─ 正确 → 继续诊断
│
├─→ 尝试: 使用备用DNS (8.8.8.8, 1.1.1.1)
│   ├─ 成功 → 记录有效DNS，继续任务
│   └─ 失败 → 域名可能已失效
│
├─→ 尝试: 直接使用IP访问 (如果已知)
│   ├─ 成功 → 记录IP，绕过DNS
│   └─ 失败 → 目标确实不可达
│
└─→ 最终: 向用户确认域名是否正确
```

### 2.3 SSL证书错误

```
SSL证书错误
│
├─→ 错误类型判断:
│   │
│   ├─ 证书过期
│   │   ├─→ 风险评估: 是否信任该网站?
│   │   │   ├─ 是 → 临时忽略证书验证 (verify=False)
│   │   │   │   └─→ 警告记录: "忽略SSL验证，存在安全风险"
│   │   │   └─ 否 → 拒绝访问，报告用户
│   │   │
│   ├─ 证书不匹配 (域名不符)
│   │   ├─→ 可能是CDN或负载均衡问题
│   │   ├─→ 尝试访问证书中的实际域名
│   │   └─→ 仍有问题 → 报告用户
│   │   │
│   └─ 自签名证书
│       ├─→ 开发/测试环境 → 允许
│       └─→ 生产环境 → 谨慎处理，询问用户
│
└─→ 禁止: 默默忽略证书错误而不记录
```

### 2.4 代理失效

```
代理失效
│
├─→ 诊断代理状态:
│   ├─→ 连接代理服务器 (超时5秒)
│   ├─→ 通过代理访问测试URL (httpbin.org/ip)
│   └─→ 验证响应是否为代理IP
│
├─→ 代理确认失效:
│   ├─→ 标记该代理为不可用
│   ├─→ 记录失效时间和原因
│   ├─→ 从代理池获取下一个代理
│   │   ├─ 有可用代理 → 使用新代理重试
│   │   └─ 无可用代理 → 进入代理恢复流程
│   │
│   └─→ 代理恢复流程:
│       ├─→ 等待 10 分钟
│       ├─→ 重新测试所有已标记失效的代理
│       ├─→ 恢复可用代理到池中
│       └─→ 仍无可用代理 → 尝试直连或报告用户
│
└─→ 代理健康监控:
    - 每个代理记录: 成功率、平均延迟、最后成功时间
    - 自动剔除: 成功率 < 50% 的代理
    - 优先使用: 成功率最高的代理
```

---

## 三、HTTP层故障决策树

### 3.1 4xx 客户端错误

```
4xx 错误处理
│
├─→ 400 Bad Request
│   ├─→ 检查: 请求参数是否正确?
│   ├─→ 检查: Content-Type 是否匹配?
│   ├─→ 检查: 编码是否正确 (UTF-8)?
│   └─→ 修正后重试，最多 3 次
│
├─→ 401 Unauthorized
│   ├─→ 需要认证
│   ├─→ 检查: 是否有可用的认证信息?
│   │   ├─ 有 → 添加认证头重试
│   │   └─ 无 → 请求用户提供认证信息
│   └─→ 禁止: 尝试猜测或暴力破解
│
├─→ 403 Forbidden
│   ├─→ 可能原因分析:
│   │   ├─ IP被封 → 切换代理
│   │   ├─ User-Agent被拒 → 更换UA
│   │   ├─ Referer验证 → 添加正确Referer
│   │   ├─ 地理限制 → 使用对应地区代理
│   │   └─ 需要登录 → 提示用户登录流程
│   │
│   ├─→ 依次尝试上述解决方案
│   ├─→ 记录每次尝试的结果
│   └─→ 全部失败 → 分析响应内容，报告用户
│
├─→ 404 Not Found
│   ├─→ 验证URL是否正确
│   ├─→ 尝试: 访问上级路径确认网站存在
│   ├─→ 尝试: 搜索该页面的替代URL
│   │   ├─ 使用站内搜索
│   │   └─ 使用 Wayback Machine
│   └─→ 确认页面已删除 → 报告用户，建议替代方案
│
├─→ 429 Too Many Requests
│   ├─→ 触发了频率限制
│   ├─→ 检查响应头: Retry-After
│   │   ├─ 有 → 等待指定时间
│   │   └─ 无 → 指数退避 (30s → 60s → 120s → 300s)
│   ├─→ 切换代理或IP
│   ├─→ 降低请求频率 (增加间隔)
│   └─→ 记录: 该网站的频率限制阈值
│
└─→ 其他4xx
    ├─→ 记录完整错误信息
    ├─→ 分析响应内容
    └─→ 报告用户并请求指导
```

### 3.2 5xx 服务端错误

```
5xx 错误处理
│
├─→ 500 Internal Server Error
│   ├─→ 服务端问题，非我方原因
│   ├─→ 等待 30 秒后重试
│   ├─→ 最多重试 5 次
│   ├─→ 尝试不同的请求方式 (GET/POST切换)
│   └─→ 仍失败 → 可能是服务端bug，记录并报告
│
├─→ 502 Bad Gateway
│   ├─→ 网关/代理服务器问题
│   ├─→ 等待 60 秒后重试
│   ├─→ 尝试不同代理
│   └─→ 检查目标服务器是否正常
│
├─→ 503 Service Unavailable
│   ├─→ 服务器过载或维护中
│   ├─→ 检查响应头: Retry-After
│   ├─→ 等待较长时间 (5-10分钟)
│   ├─→ 重试间隔递增
│   └─→ 超过30分钟仍失败 → 报告用户
│
├─→ 504 Gateway Timeout
│   ├─→ 上游服务器超时
│   ├─→ 增加等待时间
│   ├─→ 尝试更简单的请求
│   └─→ 多次失败 → 服务器可能有性能问题
│
└─→ 通用5xx处理原则:
    - 不要立即重试，给服务器恢复时间
    - 使用指数退避策略
    - 记录所有错误详情
    - 累计失败超过阈值后报告用户
```

---

## 四、反爬层故障决策树

### 4.1 验证码拦截

```
验证码处理
│
├─→ 验证码类型识别:
│   │
│   ├─ 图片验证码 (CAPTCHA)
│   │   ├─→ 尝试: OCR识别 (简单验证码)
│   │   ├─→ 尝试: 第三方打码服务 (如果配置)
│   │   ├─→ 尝试: 切换IP避开验证码
│   │   └─→ 最终: 请求用户手动处理
│   │
│   ├─ 滑动验证码
│   │   ├─→ 分析滑动轨迹要求
│   │   ├─→ 模拟人类滑动行为
│   │   │   ├─ 加速-匀速-减速曲线
│   │   │   ├─ 随机抖动
│   │   │   └─ 停顿思考
│   │   └─→ 失败多次 → 切换IP或请求用户
│   │
│   ├─ 点选验证码
│   │   ├─→ 图像识别定位目标
│   │   ├─→ 点击顺序/位置
│   │   └─→ 复杂验证码 → 请求用户
│   │
│   ├─ reCAPTCHA/hCaptcha
│   │   ├─→ 无法自动绕过
│   │   ├─→ 尝试: 2captcha等付费服务
│   │   ├─→ 尝试: 使用已验证的cookie
│   │   └─→ 必须: 请求用户手动完成
│   │
│   └─ 短信/邮箱验证码
│       └─→ 必须请求用户提供
│
├─→ 验证码绕过策略:
│   ├─→ 优先: 使用有效cookie避开验证
│   ├─→ 其次: 切换到信誉良好的IP
│   ├─→ 再次: 降低访问频率
│   └─→ 最后: 人工介入
│
└─→ 禁止行为:
    - 禁止无限重试验证码
    - 禁止使用假数据绕过
    - 必须记录验证码出现频率和类型
```

### 4.2 IP封禁

```
IP封禁处理
│
├─→ 封禁检测:
│   ├─→ 响应码 403/503
│   ├─→ 响应内容包含 "blocked", "banned", "forbidden"
│   ├─→ 重定向到验证页面
│   └─→ 连续请求无响应
│
├─→ 确认封禁后:
│   │
│   ├─→ 立即停止当前IP的所有请求
│   │
│   ├─→ 切换代理IP:
│   │   ├─→ 从代理池获取新IP
│   │   ├─→ 验证新IP可用性
│   │   ├─→ 测试新IP访问目标网站
│   │   └─→ 成功 → 继续任务
│   │
│   ├─→ 无可用代理时:
│   │   ├─→ 等待冷却 (建议 30 分钟以上)
│   │   ├─→ 尝试直连
│   │   └─→ 仍被封 → 报告用户
│   │
│   └─→ 封禁分析:
│       ├─→ 记录被封IP和封禁时间
│       ├─→ 分析封禁原因 (频率?行为?地理?)
│       └─→ 调整策略避免再次被封
│
└─→ 预防措施:
    - 控制请求频率
    - 模拟人类访问模式
    - 轮换User-Agent
    - 使用住宅代理
```

### 4.3 行为检测

```
行为检测应对
│
├─→ 检测迹象:
│   ├─→ 返回假数据或蜜罐数据
│   ├─→ 部分内容被替换或隐藏
│   ├─→ 请求被静默丢弃
│   └─→ 账号被标记高风险
│
├─→ 行为调整:
│   │
│   ├─→ 访问模式:
│   │   ├─→ 增加随机延迟 (2-10秒)
│   │   ├─→ 模拟页面浏览 (滚动、停留)
│   │   ├─→ 访问不相关页面 (混淆意图)
│   │   └─→ 降低并发数
│   │
│   ├─→ 技术指纹:
│   │   ├─→ 启用真实浏览器
│   │   ├─→ 使用 Playwright/Puppeteer
│   │   ├─→ 绑定真实设备指纹
│   │   └─→ 通过 Canvas/WebGL 指纹检测
│   │
│   └─→ 会话行为:
│       ├─→ 先访问首页再进入目标页
│       ├─→ 维持合理的会话时长
│       └─→ 模拟点击、移动鼠标
│
└─→ 数据验证:
    - 交叉验证获取的数据
    - 对比历史数据检测异常
    - 发现蜜罐数据立即停止
```

---

## 五、数据层故障决策树

### 5.1 元素定位失败

```
元素定位失败
│
├─→ 原因排查:
│   │
│   ├─→ 页面未完全加载
│   │   ├─→ 等待更长时间 (显式等待)
│   │   ├─→ 等待特定元素出现
│   │   └─→ 监听 DOMContentLoaded/load 事件
│   │
│   ├─→ 元素在 iframe 中
│   │   ├─→ 检测所有 iframe
│   │   ├─→ 切换到对应 iframe
│   │   └─→ 重新定位元素
│   │
│   ├─→ 元素由 JS 动态生成
│   │   ├─→ 等待 JS 执行完成
│   │   ├─→ 使用 MutationObserver 监听
│   │   └─→ 触发生成元素的操作
│   │
│   ├─→ 选择器已失效 (页面结构变化)
│   │   ├─→ 尝试备用选择器
│   │   ├─→ 使用模糊匹配 (文本、属性)
│   │   ├─→ 使用 AI 分析页面结构
│   │   └─→ 更新选择器库
│   │
│   └─→ 元素确实不存在
│       ├─→ 确认目标页面正确
│       ├─→ 检查是否需要登录
│       └─→ 页面改版 → 报告用户
│
├─→ 选择器策略优先级:
│   1. ID 选择器 (最稳定)
│   2. data-* 属性选择器
│   3. 语义化 class
│   4. 文本内容匹配
│   5. XPath 结构定位 (最后手段)
│
└─→ 禁止行为:
    - 禁止返回空数据假装成功
    - 禁止使用硬编码位置 (第3个div)
    - 必须记录定位失败详情
```

### 5.2 数据格式变化

```
数据格式变化处理
│
├─→ 检测:
│   ├─→ 预期字段缺失
│   ├─→ 字段类型改变
│   ├─→ 数据结构变化 (嵌套变化)
│   └─→ 值域超出预期范围
│
├─→ 响应:
│   │
│   ├─→ 字段缺失:
│   │   ├─→ 检查是否在其他位置
│   │   ├─→ 使用默认值 (如果合理)
│   │   └─→ 标记为 "字段缺失" (不伪造)
│   │
│   ├─→ 类型改变:
│   │   ├─→ 尝试类型转换
│   │   ├─→ 转换失败 → 保留原始值
│   │   └─→ 记录类型变化
│   │
│   └─→ 结构变化:
│       ├─→ 使用灵活的解析逻辑
│       ├─→ 记录新结构
│       └─→ 重大变化 → 报告用户
│
└─→ 数据验证规则:
    - 必填字段必须有值 (或明确标记缺失)
    - 数值字段检查合理范围
    - 日期字段检查格式
    - URL 字段检查可访问性
```

### 5.3 内容为空

```
内容为空处理
│
├─→ 区分情况:
│   │
│   ├─→ 页面本身为空 (合法状态)
│   │   ├─→ 确认: 是搜索无结果等预期情况?
│   │   ├─→ 是 → 返回空结果，状态标记为 "no_results"
│   │   └─→ 否 → 继续排查
│   │
│   ├─→ 反爬导致内容被清空
│   │   ├─→ 检查: 是否触发了保护机制?
│   │   ├─→ 查看页面源码是否有内容
│   │   ├─→ 对比有无JS执行的差异
│   │   └─→ 确认反爬 → 升级反检测措施
│   │
│   └─→ 解析逻辑错误
│       ├─→ 检查选择器是否正确
│       ├─→ 检查是否需要滚动加载
│       └─→ 检查是否需要点击展开
│
├─→ 验证内容真实性:
│   ├─→ 截图保存当时页面
│   ├─→ 保存原始HTML
│   └─→ 记录请求和响应详情
│
└─→ 禁止:
    - 禁止返回伪造的数据填充
    - 禁止默默跳过空内容
    - 必须明确标注为何为空
```

---

## 六、浏览器层故障决策树

### 6.1 页面崩溃

```
页面崩溃处理
│
├─→ 崩溃检测:
│   ├─→ 浏览器进程退出
│   ├─→ 页面长时间无响应
│   └─→ DevTools 协议断开
│
├─→ 恢复流程:
│   ├─→ 关闭当前浏览器实例
│   ├─→ 等待 5 秒
│   ├─→ 创建新的浏览器实例
│   ├─→ 恢复 cookies 和状态
│   └─→ 从断点继续任务
│
├─→ 原因分析:
│   ├─→ 内存不足 → 减少并行页面数
│   ├─→ 页面脚本问题 → 禁用JS重试
│   └─→ 扩展冲突 → 禁用扩展
│
└─→ 预防:
    - 定期重启浏览器 (每100页)
    - 监控内存使用
    - 限制单页面加载时间
```

### 6.2 资源加载失败

```
资源加载失败
│
├─→ 影响评估:
│   │
│   ├─→ 关键资源 (HTML/核心JS)
│   │   ├─→ 必须重试
│   │   ├─→ 重试 3 次
│   │   └─→ 失败 → 切换网络/代理
│   │
│   ├─→ 数据资源 (API/JSON)
│   │   ├─→ 重试获取
│   │   ├─→ 检查是否有备用接口
│   │   └─→ 无法获取 → 标记数据不完整
│   │
│   └─→ 非关键资源 (图片/CSS/字体)
│       ├─→ 可以忽略
│       └─→ 继续任务
│
└─→ 网络优化:
    - 拦截不必要的资源请求
    - 缓存静态资源
    - 并行加载优化
```

---

## 七、逻辑层故障决策树

### 7.1 无限循环检测

```
无限循环检测与处理
│
├─→ 检测信号:
│   ├─→ 同一URL连续访问 > 3 次
│   ├─→ 同一操作重复执行 > 5 次
│   ├─→ 任务执行时间异常长
│   └─→ 数据重复采集
│
├─→ 处理:
│   ├─→ 立即暂停当前操作
│   ├─→ 记录循环状态:
│   │   - 循环的操作是什么
│   │   - 已循环多少次
│   │   - 每次循环的结果
│   ├─→ 分析循环原因
│   └─→ 跳出循环，尝试替代方案
│
├─→ 预防机制:
│   ├─→ 维护访问URL集合
│   ├─→ 操作计数器
│   ├─→ 全局超时设置
│   └─→ 进度检查点
│
└─→ 禁止:
    - 禁止无限重试
    - 每种操作必须有最大重试次数
```

### 7.2 状态丢失

```
状态丢失恢复
│
├─→ 需要持久化的状态:
│   ├─→ 当前任务进度
│   ├─→ 已访问的URL列表
│   ├─→ 已采集的数据
│   ├─→ 登录状态 (cookies)
│   └─→ 代理轮换位置
│
├─→ 状态检查点:
│   ├─→ 每完成一个URL保存一次
│   ├─→ 每5分钟自动保存
│   └─→ 关键操作前后保存
│
├─→ 恢复流程:
│   ├─→ 加载最近的检查点
│   ├─→ 验证检查点数据完整性
│   ├─→ 从检查点继续执行
│   └─→ 检查点损坏 → 从头开始，标记已完成部分
│
└─→ 存储位置:
    - 本地: task_state_{task_id}.json
    - 格式: 包含时间戳、进度、数据
```

---

## 八、故障上报格式

所有故障必须按以下格式记录，确保可追溯:

```json
{
  "fault_id": "uuid",
  "timestamp": "ISO 8601",
  "task_id": "关联任务",
  "fault_category": "network|http|anti-crawl|data|browser|logic",
  "fault_type": "具体类型",
  "severity": "critical|high|medium|low",

  "context": {
    "url": "相关URL",
    "proxy": "使用的代理",
    "browser": "浏览器信息",
    "request": "请求详情",
    "response": "响应详情"
  },

  "diagnosis": {
    "possible_causes": ["可能原因1", "可能原因2"],
    "actual_cause": "确定的原因",
    "evidence": "判断依据"
  },

  "resolution": {
    "attempts": [
      {
        "action": "采取的措施",
        "result": "success|failure",
        "details": "详情"
      }
    ],
    "final_action": "最终解决方案",
    "outcome": "resolved|escalated|unresolved"
  },

  "prevention": {
    "lessons": "经验教训",
    "recommended_changes": "建议的改进"
  }
}
```

---

## 九、故障升级流程

```
故障处理流程
│
├─→ Level 1: 自动处理 (0-30秒)
│   ├─→ 重试
│   ├─→ 切换代理
│   ├─→ 调整参数
│   └─→ 成功率要求: > 80%
│
├─→ Level 2: 智能诊断 (30秒-5分钟)
│   ├─→ 运行诊断模块
│   ├─→ 尝试多种解决方案
│   ├─→ 参考历史经验
│   └─→ 成功率要求: > 60%
│
├─→ Level 3: 策略调整 (5-30分钟)
│   ├─→ 切换访问策略
│   ├─→ 更换入口方式
│   ├─→ 降级处理
│   └─→ 等待冷却
│
└─→ Level 4: 用户介入
    ├─→ 清晰描述问题
    ├─→ 提供已尝试的方案
    ├─→ 给出建议选项
    └─→ 等待用户决策
```

---

## 诊断日志格式

```yaml
fault_diagnosis:
  timestamp: "检测时间"
  fault_type: "故障类型"
  initial_assessment: "初始判断"

  diagnostic_steps:
    - step: 1
      action: "执行的诊断"
      finding: "发现"
    - step: 2
      action: "下一步诊断"
      finding: "发现"

  root_cause: "根因"

  resolution_attempts:
    - attempt: 1
      method: "方法"
      result: "结果"
    - attempt: 2
      method: "方法"
      result: "结果"

  final_outcome: "最终结果"
  time_to_resolve: "耗时"

  knowledge_gained:
    pattern: "识别的模式"
    recommendation: "未来建议"
```

---

## 关联模块

- **17-feedback-loop.md** - 故障经验沉淀
- **08-diagnosis.md** - 问题诊断流程
- **14-monitoring.md** - 故障监控
- **18-brain-controller.md** - 故障触发决策
